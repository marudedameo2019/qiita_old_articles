---
title: IPから国を割り出すIPToCCを使ってみる
tags: Python
author: dameyodamedame
slide: false
---
# 序

なんかこないだIPから国を割り出すpythonコードをQiitaで見かけた

https://qiita.com/pipito-yukio/items/147f7b2f42ad9fc1dbd0

ので、PyPiにもないかなって調べてみたらこんなのを見つけました。

https://pypi.org/project/iptocc/

ふむふむpipでインストールするだけなら簡単だし、pandas使ってるみたいだからコードも素直なのでは？と今回はこれを使ってみることにしました。

# 前提

pythonなのでWindowsとかでも同じことが出来ると思いますが、今回はLinuxでの操作を前提として記述します。具体的な環境はUbuntu 22.04 + python 3.10です。

# インストール

```console
$ python3 -m venv env
$ . env/bin/activate
(env) $ pip install -U pip setuptools
(env) $ pip install pip install iptocc
(env) $
```
# 使ってみる

```console
(env) $ python
Python 3.10.12 (main, Jul 29 2024, 16:56:48) [GCC 11.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import iptocc
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/home/user/env/lib/python3.10/site-packages/iptocc/__init__.py", line 15, in <module>
    import pandas
  File "/home/user/env/lib/python3.10/site-packages/pandas/__init__.py", line 22, in <module>
    from pandas.compat import is_numpy_dev as _is_numpy_dev  # pyright: ignore # noqa:F401
  File "/home/user/env/lib/python3.10/site-packages/pandas/compat/__init__.py", line 18, in <module>
    from pandas.compat.numpy import (
  File "/home/user/env/lib/python3.10/site-packages/pandas/compat/numpy/__init__.py", line 4, in <module>
    from pandas.util.version import Version
  File "/home/user/env/lib/python3.10/site-packages/pandas/util/__init__.py", line 2, in <module>
    from pandas.util._decorators import (  # noqa:F401
  File "/home/user/env/lib/python3.10/site-packages/pandas/util/_decorators.py", line 14, in <module>
    from pandas._libs.properties import cache_readonly
  File "/home/user/env/lib/python3.10/site-packages/pandas/_libs/__init__.py", line 13, in <module>
    from pandas._libs.interval import Interval
  File "pandas/_libs/interval.pyx", line 1, in init pandas._libs.interval
ValueError: numpy.dtype size changed, may indicate binary incompatibility. Expected 96 from C header, got 88 from PyObject
>>> 
```
what? importしただけでこれですか…
そう、動かないんです。エラーメッセージでググると

https://stackoverflow.com/questions/78650222/valueerror-numpy-dtype-size-changed-may-indicate-binary-incompatibility-expec

こんなのが出てきます。ふむ…読んでみるとnumpyのバージョンが新しいとダメらしいという話なので、その辺を調べてみると、どうやら2になると不整合のあるモジュールがこうなるようですね。確認してみると…

```console
(env) $ pip list | grep -E 'numpy|pandas'
numpy           2.1.1
pandas          1.5.3
(env) $
```

ビンゴのようなので、numpyのバージョンを落として再度試してみます。

```console
(env) $ pip install "numpy<2"
...
(env) $ python
Python 3.10.12 (main, Jul 29 2024, 16:56:48) [GCC 11.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import iptocc
/home/user/env/lib/python3.10/site-packages/iptocc/__init__.py:28: FutureWarning: Passing a negative integer is deprecated in version 1.0 and will not be supported in future version. Instead, use None to not limit the column width.
  pandas.set_option("max_colwidth", -1)
>>> 
```

メッセージが変わりました。今度はiptoccパッケージ自体の問題のようです。想定しているpandasのバージョンが古すぎて、インストールしたものと合っていないみたいですね。つまりこの**iptoccパッケージは現在使用できない**というのが公式な状態のようです。

# iptoccをいじってみる

でもコードはpythonだし、そんな大変な変更でもなさそうです。パッケージインストールではなく、gitリポジトリからソースを取ってきて使ってみます。

## git clone

リポジトリはPyPiのページにリンクがあります。

https://github.com/roniemartinez/IPToCC

```console
$ git clone https://github.com/roniemartinez/IPToCC.git
...
$ cd IPToCC
$ 
```

pyproject.tomlを見てみると、

```toml
[tool.poetry.dependencies]
python = ">=3.6.1,<4"
pandas = "^1.0.1"
```

依存関係は1系のpandasしかないようです。そのまま前回同様に環境構築しておきます。

```console
$ python3 -m venv env
$ . env/bin/activate
(env) $ pip install -U pip setuptools
...
(env) $ pip install "pandas<2" "numpy<2"
...
(env) $ 
```

ではちょっと動かしてみます。
```console
(env) $ python
...
>>> import iptocc
/home/user/IPToCC/iptocc/__init__.py:28: FutureWarning: Passing a negative integer is deprecated in version 1.0 and will not be supported in future version. Instead, use None to not limit the column width.
  pandas.set_option("max_colwidth", -1)
>>> 
```

現象が再現しました。準備完了です。

## バグ修正

正確にはバグではないのですが、pandasの更新についていけてないのが問題なので、これをメッセージのとおりに修正します。

### コード

```diff_python
diff --git a/iptocc/__init__.py b/iptocc/__init__.py
index d9126a2..aa95e3b 100644
--- a/iptocc/__init__.py
+++ b/iptocc/__init__.py
@@ -25,7 +25,7 @@ logger = logging.getLogger("iptocc")
 
 pandas.set_option("display.max_columns", None)
 pandas.set_option("display.expand_frame_repr", False)
-pandas.set_option("max_colwidth", -1)
+pandas.set_option("max_colwidth", None)
 
 lock = threading.Lock()
 _rir_database: pandas.DataFrame = None
```

### 確認

```console
(env) $ python
...
>>> import iptocc
>>> iptocc.get_country_code('18.177.201.147') # qiitaのIPの1つです。
iptocc.get_country_code('18.177.201.147')
2024-09-04 00:47:04,428 INFO    __init__        18.177.201.147 is IPv4
2024-09-04 00:47:04,428 INFO    __init__        Loading RIR databases
2024-09-04 00:47:27,842 INFO    __init__        RIR databases loaded
'US'
>>>
```
動くようですが、遅いですね。23秒もかかっています。機能的にはIPv6もあるのですが、そちらはとりあえず置いておきます。他に気になるのはpandasのバージョンが古いことです。numpyともども最新に上げたいところです。

## バージョンを上げてみる

バージョンを上げて確認してみます。

```console
(env) $ pip install -U numpy pandas
...
Successfully installed numpy-2.1.1 pandas-2.2.2 tzdata-2024.1
(env) $ python
...
>>> import iptocc
>>> iptocc.get_country_code('18.177.201.147')
2024-09-04 00:55:50,282 INFO    __init__        18.177.201.147 is IPv4
2024-09-04 00:55:50,283 INFO    __init__        Loading RIR databases
2024-09-04 00:56:15,108 INFO    __init__        RIR databases loaded
'US'
>>> 
```
最新でも問題なく動くようです。時間はさっきと同じくらいかかっているようです。この時間は何をしてかかっているのでしょうか？

## 速度を上げてみる

### どこに時間がかかっているのか？

まずはどこに時間がかかっているのか調べます。loggingモジュールが時間を表示してくれるので、それを使ってしまいます。

```diff_python
diff --git a/iptocc/__init__.py b/iptocc/__init__.py
index aa95e3b..cc9c81b 100644
--- a/iptocc/__init__.py
+++ b/iptocc/__init__.py
@@ -63,9 +63,11 @@ def get_rir_database() -> pandas.DataFrame:
                     )
                     & (_rir_database["Type"] != "*")
                 ]
+                logger.info("extected ipv4 or ipv6.")
                 _rir_database[["Start", "End"]] = _rir_database.apply(
                     convert_to_ip_object, axis=1, result_type="expand"
                 )
+                logger.info("converted to objects(ip loaded).")
                 countries = pandas.read_csv(
                     os.path.join(
                         os.path.dirname(os.path.abspath(__file__)), "iso3166.csv"
@@ -78,6 +80,7 @@ def get_rir_database() -> pandas.DataFrame:
                         countries["country_name"].values,
                     )
                 )
+                logger.info("country loaded.")
                 logger.info("RIR databases loaded")
     return _rir_database
 
```

```console
(env) $ python
...
>>> import iptocc
>>> iptocc.get_country_code('18.177.201.147')
2024-09-04 01:16:52,767 INFO    __init__        18.177.201.147 is IPv4
2024-09-04 01:16:52,768 INFO    __init__        Loading RIR databases
2024-09-04 01:16:53,756 INFO    __init__        extected ipv4 or ipv6.
2024-09-04 01:17:17,478 INFO    __init__        converted to objects(ip loaded).
2024-09-04 01:17:17,480 INFO    __init__        country loaded.
2024-09-04 01:17:17,480 INFO    __init__        RIR databases loaded
'US'
>>> 
```

時間がかかっているのは以下の部分のようです。

```python
                 _rir_database[["Start", "End"]] = _rir_database.apply(
                     convert_to_ip_object, axis=1, result_type="expand"
                 )
```

ここはcsvから読んだIPとその範囲をオブジェクトに変換している部分です。IPv4とIPv6を同時に扱っているので、正確なことが分かりません。そこで…

### IPv4とIPv6に分けてみる

#### コード

```diff_python
diff --git a/iptocc/__init__.py b/iptocc/__init__.py
index cc9c81b..686c9cf 100644
--- a/iptocc/__init__.py
+++ b/iptocc/__init__.py
@@ -32,15 +32,16 @@ _rir_database: pandas.DataFrame = None
 _countries: dict = dict()
 
 
-def convert_to_ip_object(
+def convert_to_ip_object_v4(
     row: dict,
 ) -> Union[Tuple[IPv4Address, IPv4Address], Tuple[IPv6Network, str], Tuple[str, str]]:
-    if row["Type"] == "ipv4":
-        start = IPv4Address(row["Start"])
-        return start, start + int(row["Value"])
-    elif row["Type"] == "ipv6":
-        return IPv6Network(row["Start"] + "/" + row["Value"]), ""
-    return row["Start"], ""
+    start = IPv4Address(row["Start"])
+    return start, start + int(row["Value"])
+
+def convert_to_ip_object_v6(
+    row: dict,
+) -> Union[Tuple[IPv4Address, IPv4Address], Tuple[IPv6Network, str], Tuple[str, str]]:
+    return IPv6Network(row["Start"] + "/" + row["Value"]), ""
 
 
 def load_rir_databases() -> None:
@@ -56,17 +57,19 @@ def get_rir_database() -> pandas.DataFrame:
             if _rir_database is None:
                 logger.info("Loading RIR databases")
                 _rir_database = pandas.concat(read_rir_databases())
-                _rir_database = _rir_database[
-                    (
-                        (_rir_database["Type"] == "ipv4")
-                        | (_rir_database["Type"] == "ipv6")
-                    )
-                    & (_rir_database["Type"] != "*")
-                ]
-                logger.info("extected ipv4 or ipv6.")
-                _rir_database[["Start", "End"]] = _rir_database.apply(
-                    convert_to_ip_object, axis=1, result_type="expand"
+                _rir_database = _rir_database[_rir_database["Type"] != "*"]
+                _rir_database_v4 = _rir_database[_rir_database["Type"] == "ipv4"]
+                _rir_database_v6 = _rir_database[_rir_database["Type"] == "ipv6"]
+                logger.info("extracted ipv4 or ipv6.")
+                _rir_database_v4[["Start", "End"]] = _rir_database_v4.apply(
+                    convert_to_ip_object_v4, axis=1, result_type="expand"
+                )
+                logger.info("converted to objects(ipv4).")
+                _rir_database_v6[["Start", "End"]] = _rir_database_v6.apply(
+                    convert_to_ip_object_v6, axis=1, result_type="expand"
                 )
+                logger.info("converted to objects(ipv6).")
+                _rir_database = pandas.concat([_rir_database_v4, _rir_database_v6])
                 logger.info("converted to objects(ip loaded).")
                 countries = pandas.read_csv(
                     os.path.join(
```

#### 実行

```console
>>> import iptocc
>>> iptocc.get_country_code('18.177.201.147')
2024-09-04 01:35:38,485 INFO    __init__        18.177.201.147 is IPv4
2024-09-04 01:35:38,486 INFO    __init__        Loading RIR databases
2024-09-04 01:35:39,541 INFO    __init__        extracted ipv4 or ipv6.
/home/user/IPToCC/iptocc/__init__.py:64: SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  _rir_database_v4[["Start", "End"]] = _rir_database_v4.apply(
/home/user/IPToCC/iptocc/__init__.py:64: SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  _rir_database_v4[["Start", "End"]] = _rir_database_v4.apply(
2024-09-04 01:35:49,918 INFO    __init__        converted to objects(ipv4).
/home/user/IPToCC/iptocc/__init__.py:68: SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  _rir_database_v6[["Start", "End"]] = _rir_database_v6.apply(
/home/user/IPToCC/iptocc/__init__.py:68: SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  _rir_database_v6[["Start", "End"]] = _rir_database_v6.apply(
2024-09-04 01:36:03,034 INFO    __init__        converted to objects(ipv6).
2024-09-04 01:36:03,079 INFO    __init__        converted to objects(ip loaded).
2024-09-04 01:36:03,082 INFO    __init__        country loaded.
2024-09-04 01:36:03,082 INFO    __init__        RIR databases loaded
'US'
>>> 
```

何かメッセージが出ていますが、とりあえず無視して読むと、ipv4で10秒、ipv6で13秒かかっているようです。メッセージの方は示されたURLは以下のとおり。

https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy

コピーオンライトをONにする対応を入れてみます。

```diff_python
diff --git a/iptocc/__init__.py b/iptocc/__init__.py
index 686c9cf..716e2ac 100644
--- a/iptocc/__init__.py
+++ b/iptocc/__init__.py
@@ -26,6 +26,7 @@ logger = logging.getLogger("iptocc")
 pandas.set_option("display.max_columns", None)
 pandas.set_option("display.expand_frame_repr", False)
 pandas.set_option("max_colwidth", None)
+pandas.options.mode.copy_on_write = True
 
 lock = threading.Lock()
 _rir_database: pandas.DataFrame = None
```

結果は以下のとおり。

```console
>>> import iptocc
>>> iptocc.get_country_code('18.177.201.147')
2024-09-04 01:52:28,534 INFO    __init__        18.177.201.147 is IPv4
2024-09-04 01:52:28,535 INFO    __init__        Loading RIR databases
2024-09-04 01:52:29,536 INFO    __init__        extracted ipv4 or ipv6.
2024-09-04 01:52:39,505 INFO    __init__        converted to objects(ipv4).
2024-09-04 01:52:52,240 INFO    __init__        converted to objects(ipv6).
2024-09-04 01:52:52,296 INFO    __init__        converted to objects(ip loaded).
2024-09-04 01:52:52,298 INFO    __init__        country loaded.
2024-09-04 01:52:52,299 INFO    __init__        RIR databases loaded
'US'
>>> 
```

メッセージが消えただけでしたね。こうなったらもう関数をぐっちゃり中に入れてしまいます。

### 関数をラムダにして中に入れる

#### コード

```diff_python
diff --git a/iptocc/__init__.py b/iptocc/__init__.py
index 716e2ac..8f907c8 100644
--- a/iptocc/__init__.py
+++ b/iptocc/__init__.py
@@ -33,18 +33,6 @@ _rir_database: pandas.DataFrame = None
 _countries: dict = dict()
 
 
-def convert_to_ip_object_v4(
-    row: dict,
-) -> Union[Tuple[IPv4Address, IPv4Address], Tuple[IPv6Network, str], Tuple[str, str]]:
-    start = IPv4Address(row["Start"])
-    return start, start + int(row["Value"])
-
-def convert_to_ip_object_v6(
-    row: dict,
-) -> Union[Tuple[IPv4Address, IPv4Address], Tuple[IPv6Network, str], Tuple[str, str]]:
-    return IPv6Network(row["Start"] + "/" + row["Value"]), ""
-
-
 def load_rir_databases() -> None:
     get_rir_database()
 
@@ -62,13 +50,11 @@ def get_rir_database() -> pandas.DataFrame:
                 _rir_database_v4 = _rir_database[_rir_database["Type"] == "ipv4"]
                 _rir_database_v6 = _rir_database[_rir_database["Type"] == "ipv6"]
                 logger.info("extracted ipv4 or ipv6.")
-                _rir_database_v4[["Start", "End"]] = _rir_database_v4.apply(
-                    convert_to_ip_object_v4, axis=1, result_type="expand"
-                )
+                _rir_database_v4["Start"] = _rir_database_v4["Start"].apply(lambda s: IPv4Address(s))
+                _rir_database_v4["End"] = _rir_database_v4.apply(lambda row: row["Start"] + int(row["Value"]), axis=1, result_type="expand")
                 logger.info("converted to objects(ipv4).")
-                _rir_database_v6[["Start", "End"]] = _rir_database_v6.apply(
-                    convert_to_ip_object_v6, axis=1, result_type="expand"
-                )
+                _rir_database_v6["Start"] = _rir_database_v6.apply(lambda row: IPv6Network(row["Start"] + "/" + row["Value"]), axis=1, result_type="expand")
+                _rir_database_v6["End"] = ""
                 logger.info("converted to objects(ipv6).")
                 _rir_database = pandas.concat([_rir_database_v4, _rir_database_v6])
                 logger.info("converted to objects(ip loaded).")
```

#### 実行

```console
>>> import iptocc
>>> iptocc.get_country_code('18.177.201.147')
2024-09-04 02:04:36,585 INFO    __init__        18.177.201.147 is IPv4
2024-09-04 02:04:36,585 INFO    __init__        Loading RIR databases
2024-09-04 02:04:37,558 INFO    __init__        extracted ipv4 or ipv6.
2024-09-04 02:04:40,844 INFO    __init__        converted to objects(ipv4).
2024-09-04 02:04:46,634 INFO    __init__        converted to objects(ipv6).
2024-09-04 02:04:46,686 INFO    __init__        converted to objects(ip loaded).
2024-09-04 02:04:46,688 INFO    __init__        country loaded.
2024-09-04 02:04:46,689 INFO    __init__        RIR databases loaded
'US'
>>> 
```

メンテナンス性を多少(?)犠牲にすることにより、ipv4が3秒、ipv6が6秒まで縮んで、全体で23秒かかってたのが10秒まで高速化できました。

## 全体のパッチ

ここまでのパッチをまとめたパッチです。

```diff_python
diff --git a/iptocc/__init__.py b/iptocc/__init__.py
index d9126a2..8f907c8 100644
--- a/iptocc/__init__.py
+++ b/iptocc/__init__.py
@@ -25,24 +25,14 @@ logger = logging.getLogger("iptocc")
 
 pandas.set_option("display.max_columns", None)
 pandas.set_option("display.expand_frame_repr", False)
-pandas.set_option("max_colwidth", -1)
+pandas.set_option("max_colwidth", None)
+pandas.options.mode.copy_on_write = True
 
 lock = threading.Lock()
 _rir_database: pandas.DataFrame = None
 _countries: dict = dict()
 
 
-def convert_to_ip_object(
-    row: dict,
-) -> Union[Tuple[IPv4Address, IPv4Address], Tuple[IPv6Network, str], Tuple[str, str]]:
-    if row["Type"] == "ipv4":
-        start = IPv4Address(row["Start"])
-        return start, start + int(row["Value"])
-    elif row["Type"] == "ipv6":
-        return IPv6Network(row["Start"] + "/" + row["Value"]), ""
-    return row["Start"], ""
-
-
 def load_rir_databases() -> None:
     get_rir_database()
 
@@ -56,16 +46,18 @@ def get_rir_database() -> pandas.DataFrame:
             if _rir_database is None:
                 logger.info("Loading RIR databases")
                 _rir_database = pandas.concat(read_rir_databases())
-                _rir_database = _rir_database[
-                    (
-                        (_rir_database["Type"] == "ipv4")
-                        | (_rir_database["Type"] == "ipv6")
-                    )
-                    & (_rir_database["Type"] != "*")
-                ]
-                _rir_database[["Start", "End"]] = _rir_database.apply(
-                    convert_to_ip_object, axis=1, result_type="expand"
-                )
+                _rir_database = _rir_database[_rir_database["Type"] != "*"]
+                _rir_database_v4 = _rir_database[_rir_database["Type"] == "ipv4"]
+                _rir_database_v6 = _rir_database[_rir_database["Type"] == "ipv6"]
+                logger.info("extracted ipv4 or ipv6.")
+                _rir_database_v4["Start"] = _rir_database_v4["Start"].apply(lambda s: IPv4Address(s))
+                _rir_database_v4["End"] = _rir_database_v4.apply(lambda row: row["Start"] + int(row["Value"]), axis=1, result_type="expand")
+                logger.info("converted to objects(ipv4).")
+                _rir_database_v6["Start"] = _rir_database_v6.apply(lambda row: IPv6Network(row["Start"] + "/" + row["Value"]), axis=1, result_type="expand")
+                _rir_database_v6["End"] = ""
+                logger.info("converted to objects(ipv6).")
+                _rir_database = pandas.concat([_rir_database_v4, _rir_database_v6])
+                logger.info("converted to objects(ip loaded).")
                 countries = pandas.read_csv(
                     os.path.join(
                         os.path.dirname(os.path.abspath(__file__)), "iso3166.csv"
@@ -78,6 +70,7 @@ def get_rir_database() -> pandas.DataFrame:
                         countries["country_name"].values,
                     )
                 )
+                logger.info("country loaded.")
                 logger.info("RIR databases loaded")
     return _rir_database

 ```

# まとめ

- iptoccはそのままでは動かない
- numpyのバージョンを適切に設定し、コードを一部修正することで動作するようになる
- 最新python環境に適応させる手順を示した
- 速度を倍程度高速化するパッチを作成した

今後はRIRデータベースの更新とやらも見て、データの持ち方をオブジェクトから文字列などにし、pandas経由でSQL Alchemyなどを使ってsqliteに入れたりしてみれば、実用可能になるかと思う。

----

# 【追記】その1

ここまではgithubのコードを動かすことを前提とした修正をしたわけですが、(面倒だったので)環境そのものはあまり気にしていませんでした。本節では元の環境についてもある程度復元してみます。

## poetry環境の復元

IPToCCで使用されている環境はpoetryという環境です。詳細はドキュメントを読んで下さい。

https://python-poetry.org/docs/

本来poetry環境はpoetryをインストールしてpoetry installすれば復元します。

しかしやってみると…

```console
# 最初から環境を構築
$ python3 -m venv env
$ . env/bin/activate
(env) $ pip install -U pip setuptools
...
(env) $ git clone https://github.com/roniemartinez/IPToCC.git
...
(env) $ cd IPToCC
(env) $ make install # 中でpoetryをインストールしてpoetry installしている
...
Cannot install pyyaml.

  - Installing toml (0.10.0)
  - Downgrading urllib3 (2.2.2 -> 1.25.8)
  - Installing wcwidth (0.1.8)
make: *** [Makefile:3: install] エラー 1
(env) $ 
```

案の定これも古すぎてうまくインストールできません。実際にはpythonのランタイムが新しくてうまく動かない感じなのですが、追っかけるとキリがないレベルで問題が起きそうです。

## とりあえずバージョンロックファイルの削除

そこで今回はとりあえず`poetry.lock`という各パッケージのバージョンを固定しているファイルを一旦削除して、試してみます。

```console
(env) $ rm poetry.lock
(env) $ make install
...
Updating dependencies
Resolving dependencies... (44.6s)
...
  - Installing numpy (1.19.5): Failed

  ChefBuildError
...
(env) $ 
```

すると今度は依存関係を再構築して適切にバージョンを決めてくれていそうです。ただし、最終的にはこれもエラーで失敗しています。失敗しているのはnumpyのビルドです。かなり古いバージョンを使っており、これはどうやっても無理そうです。

## 依存パッケージのバージョン定義を更新

なので、次は依存パッケージのバージョン定義を新しく再挑戦してみます。

```diff_toml
diff --git a/pyproject.toml b/pyproject.toml
index effba83..6cb4087 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -33,8 +33,8 @@ classifiers = [
 update_rir = "updater:update_rir_databases"
 
 [tool.poetry.dependencies]
-python = ">=3.6.1,<4"
-pandas = "^1.0.1"
+python = ">=3.9,<4"
+pandas = "^2.2"
 
 [tool.poetry.dev-dependencies]
 codecov = "^2.0.16"
```

```console
(env) $ make install
...
(env) $ 
```

ようやく成功です。

## install以外のmakeターゲットを試す

他にもmakeのターゲットがいくつかあるので、動かしてみます。

### 拙作パッチを当てる

中にはテストなどもあるので、動くようにするべく、私のパッチもgit applyで当てておきます。

```console
(env) $ git apply <<EOF
(パッチをコピペ)
EOF
(env) $ 
```

### make optional

追加のパッケージをインストールするターゲットのようです。他のターゲットの実行で必要なパッケージのようです。

```
(env) $ make optional
...
(env) 
```

実行してみると問題なくインストールされます。

### make style

コーディングスタイルを統一させるためのツールを実行するようです。

```console
(env) $ make style
...
./iptocc/__init__.py:13:1: F401 'typing.Tuple' imported but unused
./iptocc/__init__.py:13:1: F401 'typing.Union' imported but unused
...
(env) $ 
```

何か怒られました。確かにパッチで関数を削除したためtype hintが不要になってました。以下の修正を入れると怒られなくなります。

```diff_python
diff --git a/iptocc/__init__.py b/iptocc/__init__.py
index 8f907c8..856f65b 100644
--- a/iptocc/__init__.py
+++ b/iptocc/__init__.py
@@ -10,7 +10,6 @@ import sys
 import threading
 from functools import lru_cache
 from ipaddress import IPv4Address, IPv6Address, IPv6Network, ip_address
-from typing import Union, Tuple
 
 import pandas
 
```

上記のエラーは微妙にスタイルとは違う気もしますが、しれっとフォーマットされていたりします。

### make type

これはpylintのようなツールで諸々の良くないとされる実装を指摘されます。実行すると…

```console
(env) $ make type
...
iptocc/__init__.py: error: Source file found twice under different module names: "..." and "..."
...
(env) $ 
```

エラーが出ます。これはmypyというツールのバージョンが上がって、呼び出し方が変わったから出たエラーのようです。以下のように修正してリトライです。

```diff_make
diff --git a/Makefile b/Makefile
index 723a8ff..d42e320 100644
--- a/Makefile
+++ b/Makefile
@@ -11,7 +11,7 @@ style:
        poetry run flake8
 
 type:
-       poetry run mypy --ignore-missing-imports tests iptocc
+       poetry run mypy --ignore-missing-imports -p tests -p iptocc
 
 check:
        poetry run safety check
```

```console
(env) $ make type
...
iptocc/__init__.py:145: error: Incompatible types in assignment (expression has type "IPv4Address | IPv6Address", variable has type "str")  [assignment]
...
(env) $ 
```

メッセージが変わり、type hintに書かれた変数の型と違うものが割り当てられたと怒られています。以下の修正で通知はなくなります。

```diff_python
@@ -133,12 +142,12 @@ def ipv6_get_country_code(address: IPv6Address) -> str:
 
 
 def get_country_code(address: str) -> str:
-    address = ip_address(address)
-    if isinstance(address, IPv4Address):
-        logger.info("%s is IPv4", address)
-        return ipv4_get_country_code(address)
-    logger.info("%s is IPv6", address)
-    return ipv6_get_country_code(address)
+    ip  = ip_address(address)
+    if isinstance(ip, IPv4Address):
+        logger.info("%s is IPv4", ip)
+        return ipv4_get_country_code(ip)
+    logger.info("%s is IPv6", ip)
+    return ipv6_get_country_code(ip)
 
 
 def get_country(address: str) -> str:
```

### make check

```console
(env) $ make check
poetry run safety check
+==============================================================================+
|                                                                              |
|                               /$$$$$$            /$$                         |
|                              /$$__  $$          | $$                         |
|           /$$$$$$$  /$$$$$$ | $$  \__//$$$$$$  /$$$$$$   /$$   /$$           |
|          /$$_____/ |____  $$| $$$$   /$$__  $$|_  $$_/  | $$  | $$           |
|         |  $$$$$$   /$$$$$$$| $$_/  | $$$$$$$$  | $$    | $$  | $$           |
|          \____  $$ /$$__  $$| $$    | $$_____/  | $$ /$$| $$  | $$           |
|          /$$$$$$$/|  $$$$$$$| $$    |  $$$$$$$  |  $$$$/|  $$$$$$$           |
|         |_______/  \_______/|__/     \_______/   \___/   \____  $$           |
|                                                          /$$  | $$           |
|                                                         |  $$$$$$/           |
|  by pyup.io                                              \______/            |
|                                                                              |
+==============================================================================+
| REPORT                                                                       |
| checked 97 packages, using free DB (updated once a month)                    |
+============================+===========+==========================+==========+
| package                    | installed | affected                 | ID       |
+============================+===========+==========================+==========+
| pipenv                     | 2018.11.2 | <2020.5.28               | 38334    |
| pipenv                     | 2018.11.2 | <2020.5.28               | 45800    |
| pipenv                     | 2018.11.2 | <2020.5.28               | 45802    |
| pipenv                     | 2018.11.2 | <2020.5.28               | 45801    |
| pipenv                     | 2018.11.2 | <2020.5.28               | 45798    |
| pipenv                     | 2018.11.2 | <2020.5.28               | 45799    |
| pipenv                     | 2018.11.2 | >=2018.10.9,<=2021.11.23 | 44492    |
| py                         | 1.11.0    | <=1.11.0                 | 51457    |
| safety                     | 1.10.3    | <2.2.0                   | 51358    |
+==============================================================================+
...
make: *** [Makefile:17: check] エラー 255
(env) $ 
```

安全そうに見えてエラー終了しています。safetyというのは状態ではなくロゴなのです。下に出ているパッケージは**安全でないパッケージ**のリストです。普通にpoetry updateしてもすでに最新なので何も起きません。これらのパッケージのバージョンをどうにかするにはpyproject.tomlをいじります。

```diff_toml
diff --git a/pyproject.toml b/pyproject.toml
index effba83..65f817a 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -33,17 +33,18 @@ classifiers = [
 update_rir = "updater:update_rir_databases"
 
 [tool.poetry.dependencies]
-python = ">=3.6.1,<4"
-pandas = "^1.0.1"
+python = ">=3.9,<4"
+pandas = "^2.2"
 
 [tool.poetry.dev-dependencies]
 codecov = "^2.0.16"
-pytest = "^5.4.1"
+pytest = "^8"
 pytest-cov = "^2.8.1"
 flake8 = "^3.7.9"
 isort = "^4.3.21"
-safety = "^1.8.7"
+safety = "^3.2"
 bandit = "^1.6.2"
+pipenv = ">=2024.0.1"
 
 [tool.isort]
 line_length = 99
```

このパッチを適用してupdateをかければこの定義での最新バージョンが入手できます。

```console
(env) $ poetry update
...
(env) $ make check
...
+===========================================================================================================================================================================================+
 VULNERABILITIES REPORTED 
+===========================================================================================================================================================================================+

-> Vulnerability found in jinja2 version 3.1.4
   Vulnerability ID: 70612
   Affected spec: >=0
   ADVISORY: In Jinja2, the from_string function is prone to Server Side Template Injection (SSTI) where it takes the source parameter as a template object, renders it, and then
   returns it. The attacker can exploit it with INJECTION COMMANDS in a URI. NOTE: The maintainer and multiple third parties believe that this vulnerability isn't valid because users...
   CVE-2019-8341
   For more information about this vulnerability, visit https://data.safetycli.com/v/70612/97c
   To ignore this vulnerability, use PyUp vulnerability id 70612 in safety’s ignore command-line argument or add the ignore to your safety policy file.
...
make: *** [Makefile:17: check] エラー 64
(env) $ 
```

しかし、最新の状態にしてもエラーで、これらは結局回避することも出来ませんでした。ただ問題があるかというと微妙な感じ。なぜならこのsafetyパッケージ自体が依存しているjinja2であり、良く使われるテンプレートエンジンの最新版です。

なので、このVulnerabilityはignoreしちゃいます。

```diff_make
diff --git a/Makefile b/Makefile
index 723a8ff..6d5a713 100644
--- a/Makefile
+++ b/Makefile
@@ -11,10 +11,10 @@ style:
        poetry run flake8
 
 type:
-       poetry run mypy --ignore-missing-imports tests iptocc
+       poetry run mypy --ignore-missing-imports -p tests -p iptocc
 
 check:
-       poetry run safety check
+       poetry run safety check --ignore 70612
        poetry run bandit -r iptocc
 
 test:
```

すると

```console
(env) $ make check
...
(env) $ 
```

ようやくチェックに成功します。

### make test

これは所謂テストコードです。大事なやつですね。

```console
$ make test
...
tests/test_get_country_code.py::test_invalid_ip PASSED                                                                                                                                [100%]

===================================================================================== warnings summary ======================================================================================
...: PytestDeprecationWarning: The hookimpl CovPlugin.pytest_configure_node uses old-style configuration options (marks or attributes).
  Please use the pytest.hookimpl(optionalhook=True) decorator instead
   to configure the hooks.
   See https://docs.pytest.org/en/latest/deprecations.html#configuring-hook-specs-impls-using-markers
    def pytest_configure_node(self, node):

...: PytestDeprecationWarning: The hookimpl CovPlugin.pytest_testnodedown uses old-style configuration options (marks or attributes).
  Please use the pytest.hookimpl(optionalhook=True) decorator instead
   to configure the hooks.
   See https://docs.pytest.org/en/latest/deprecations.html#configuring-hook-specs-impls-using-markers
    def pytest_testnodedown(self, node, error):

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Coverage XML written to file coverage.xml

============================================================================== 12 passed, 2 warnings in 28.53s ==============================================================================
(env) $ 
```

テスト自体は成功して、設定がdeprecatedな警告が2つ出ているようです。カバレッジもしていますが、そちらは置いておきます。

警告の原因はどうやらpytest-covのコードが古いせいなので、こいつのバージョンを上げてやります。

```diff_toml
diff --git a/pyproject.toml b/pyproject.toml
index effba83..9c301f6 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -33,17 +33,18 @@ classifiers = [
 update_rir = "updater:update_rir_databases"
 
 [tool.poetry.dependencies]
-python = ">=3.6.1,<4"
-pandas = "^1.0.1"
+python = ">=3.9,<4"
+pandas = "^2.2"
 
 [tool.poetry.dev-dependencies]
 codecov = "^2.0.16"
-pytest = "^5.4.1"
-pytest-cov = "^2.8.1"
+pytest = "^8"
+pytest-cov = "^5"
 flake8 = "^3.7.9"
 isort = "^4.3.21"
-safety = "^1.8.7"
+safety = "^3.2"
 bandit = "^1.6.2"
+pipenv = ">=2024.0.1"
 
 [tool.isort]
 line_length = 99
```

実行してみると

```console
(env) $ make test
...
configfile: pyproject.toml
plugins: cov-5.0.0
collected 12 items                                                                                                                                                                          

...
tests/test_get_country_code.py::test_invalid_ip PASSED                                                                                                                                [100%]

---------- coverage: platform linux, python 3.10.12-final-0 ----------
Coverage XML written to file coverage.xml


==================================================================================== 12 passed in 28.64s ====================================================================================
(env) $ 
```

警告も消えて普通にテストも成功しています。カバレッジはXMLでも見れるのですが、手でHTMLで実行するとコードを視覚的に確認できます。いずれにしても__init__.pyで96%程度のカバレッジが確認できます。

## RIRデータベースの更新

コード的にはupdater.pyであることは明白です。コードを見れば一目瞭然ですが、iptocc/delegated-*-latestを削除すればupdater.py実行でネットからダウンロードしてくれます。

```console
(env) $ rm iptocc/delegated-*-latest
(env) $ python updater.py
...
(env) $ 
```
普通にこれだけでOK。

## ここまでのパッチ全体

```diff
diff --git a/Makefile b/Makefile
index 723a8ff..6d5a713 100644
--- a/Makefile
+++ b/Makefile
@@ -11,10 +11,10 @@ style:
 	poetry run flake8
 
 type:
-	poetry run mypy --ignore-missing-imports tests iptocc
+	poetry run mypy --ignore-missing-imports -p tests -p iptocc
 
 check:
-	poetry run safety check
+	poetry run safety check --ignore 70612
 	poetry run bandit -r iptocc
 
 test:
diff --git a/iptocc/__init__.py b/iptocc/__init__.py
index d9126a2..ea6a176 100644
--- a/iptocc/__init__.py
+++ b/iptocc/__init__.py
@@ -10,7 +10,6 @@ import sys
 import threading
 from functools import lru_cache
 from ipaddress import IPv4Address, IPv6Address, IPv6Network, ip_address
-from typing import Union, Tuple
 
 import pandas
 
@@ -25,24 +24,14 @@ logger = logging.getLogger("iptocc")
 
 pandas.set_option("display.max_columns", None)
 pandas.set_option("display.expand_frame_repr", False)
-pandas.set_option("max_colwidth", -1)
+pandas.set_option("max_colwidth", None)
+pandas.options.mode.copy_on_write = True
 
 lock = threading.Lock()
 _rir_database: pandas.DataFrame = None
 _countries: dict = dict()
 
 
-def convert_to_ip_object(
-    row: dict,
-) -> Union[Tuple[IPv4Address, IPv4Address], Tuple[IPv6Network, str], Tuple[str, str]]:
-    if row["Type"] == "ipv4":
-        start = IPv4Address(row["Start"])
-        return start, start + int(row["Value"])
-    elif row["Type"] == "ipv6":
-        return IPv6Network(row["Start"] + "/" + row["Value"]), ""
-    return row["Start"], ""
-
-
 def load_rir_databases() -> None:
     get_rir_database()
 
@@ -56,16 +45,28 @@ def get_rir_database() -> pandas.DataFrame:
             if _rir_database is None:
                 logger.info("Loading RIR databases")
                 _rir_database = pandas.concat(read_rir_databases())
-                _rir_database = _rir_database[
-                    (
-                        (_rir_database["Type"] == "ipv4")
-                        | (_rir_database["Type"] == "ipv6")
-                    )
-                    & (_rir_database["Type"] != "*")
-                ]
-                _rir_database[["Start", "End"]] = _rir_database.apply(
-                    convert_to_ip_object, axis=1, result_type="expand"
+                _rir_database = _rir_database[_rir_database["Type"] != "*"]
+                _rir_database_v4 = _rir_database[_rir_database["Type"] == "ipv4"]
+                _rir_database_v6 = _rir_database[_rir_database["Type"] == "ipv6"]
+                logger.info("extracted ipv4 or ipv6.")
+                _rir_database_v4["Start"] = _rir_database_v4["Start"].apply(
+                    lambda s: IPv4Address(s)
+                )
+                _rir_database_v4["End"] = _rir_database_v4.apply(
+                    lambda row: row["Start"] + int(row["Value"]),
+                    axis=1,
+                    result_type="expand",
+                )
+                logger.info("converted to objects(ipv4).")
+                _rir_database_v6["Start"] = _rir_database_v6.apply(
+                    lambda row: IPv6Network(row["Start"] + "/" + row["Value"]),
+                    axis=1,
+                    result_type="expand",
                 )
+                _rir_database_v6["End"] = ""
+                logger.info("converted to objects(ipv6).")
+                _rir_database = pandas.concat([_rir_database_v4, _rir_database_v6])
+                logger.info("converted to objects(ip loaded).")
                 countries = pandas.read_csv(
                     os.path.join(
                         os.path.dirname(os.path.abspath(__file__)), "iso3166.csv"
@@ -78,6 +79,7 @@ def get_rir_database() -> pandas.DataFrame:
                         countries["country_name"].values,
                     )
                 )
+                logger.info("country loaded.")
                 logger.info("RIR databases loaded")
     return _rir_database
 
@@ -140,12 +142,12 @@ def ipv6_get_country_code(address: IPv6Address) -> str:
 
 
 def get_country_code(address: str) -> str:
-    address = ip_address(address)
-    if isinstance(address, IPv4Address):
-        logger.info("%s is IPv4", address)
-        return ipv4_get_country_code(address)
-    logger.info("%s is IPv6", address)
-    return ipv6_get_country_code(address)
+    ip = ip_address(address)
+    if isinstance(ip, IPv4Address):
+        logger.info("%s is IPv4", ip)
+        return ipv4_get_country_code(ip)
+    logger.info("%s is IPv6", ip)
+    return ipv6_get_country_code(ip)
 
 
 def get_country(address: str) -> str:
diff --git a/pyproject.toml b/pyproject.toml
index effba83..9c301f6 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -33,17 +33,18 @@ classifiers = [
 update_rir = "updater:update_rir_databases"
 
 [tool.poetry.dependencies]
-python = ">=3.6.1,<4"
-pandas = "^1.0.1"
+python = ">=3.9,<4"
+pandas = "^2.2"
 
 [tool.poetry.dev-dependencies]
 codecov = "^2.0.16"
-pytest = "^5.4.1"
-pytest-cov = "^2.8.1"
+pytest = "^8"
+pytest-cov = "^5"
 flake8 = "^3.7.9"
 isort = "^4.3.21"
-safety = "^1.8.7"
+safety = "^3.2"
 bandit = "^1.6.2"
+pipenv = ">=2024.0.1"
 
 [tool.isort]
 line_length = 99
diff --git a/tests/test_get_country_code.py b/tests/test_get_country_code.py
index 4170a5b..88c56d2 100644
--- a/tests/test_get_country_code.py
+++ b/tests/test_get_country_code.py
@@ -11,8 +11,16 @@ from iptocc import CountryCodeNotFound, get_country_code
 PARAMS = [
     ("United States - IPv4", "5.35.192.0", "US"),
     ("Sweden - IPv4", "5.35.184.0", "SE"),
-    ("United States - IPv6", "2a00:5440:0000:0000:0000:ff00:0042:8329", "US",),
-    ("United Kingdom - IPv6", "2a00:95e0:0000:0000:0000:ff00:0042:8329", "GB",),
+    (
+        "United States - IPv6",
+        "2a00:5440:0000:0000:0000:ff00:0042:8329",
+        "US",
+    ),
+    (
+        "United Kingdom - IPv6",
+        "2a00:95e0:0000:0000:0000:ff00:0042:8329",
+        "GB",
+    ),
 ]
 
 
 ```
 
 ※git clone後、このパッチを当ててpoetry.lockを削除すれば大体動きます
 
 ## 追記その1のまとめ
 
- poetry環境なども全て最新に合わせて使えるようにしてみた
- RIRデータベースの更新方法を習得した

これでようやく機能追加などが出来る状態になったと思う。

# 【追記】その2

今回はSQL Alchemyを使ってSQLite3に入れてみます。

## パッチ

以前のものも含めて全部入りのパッチです。

```diff
diff --git a/Makefile b/Makefile
index 723a8ff..f5d37fa 100644
--- a/Makefile
+++ b/Makefile
@@ -6,15 +6,15 @@ optional:
 	poetry run pip install black mypy
 
 style:
-	poetry run isort -rc --atomic .
+	poetry run isort --atomic .
 	poetry run black .
 	poetry run flake8
 
 type:
-	poetry run mypy --ignore-missing-imports tests iptocc
+	poetry run mypy --ignore-missing-imports -p tests -p iptocc
 
 check:
-	poetry run safety check
+	poetry run safety check --ignore 70612
 	poetry run bandit -r iptocc
 
 test:
diff --git a/iptocc/__init__.py b/iptocc/__init__.py
index d9126a2..531119c 100644
--- a/iptocc/__init__.py
+++ b/iptocc/__init__.py
@@ -8,69 +8,90 @@ import logging
 import os
 import sys
 import threading
-from functools import lru_cache
-from ipaddress import IPv4Address, IPv6Address, IPv6Network, ip_address
-from typing import Union, Tuple
+from ipaddress import IPv4Address, ip_address
+from typing import Annotated, Optional
 
 import pandas
+from sqlalchemy import String, create_engine, func, select
+from sqlalchemy.engine import Engine
+from sqlalchemy.orm import DeclarativeBase, Mapped, Session, mapped_column
 
 from iptocc.exceptions import CountryCodeNotFound, CountryNotFound
 
 logging.basicConfig(
     stream=sys.stdout,
-    level=logging.DEBUG,
+    level=logging.ERROR,
     format="%(asctime)s\t%(levelname)s\t%(module)s\t%(message)s",
 )
 logger = logging.getLogger("iptocc")
 
 pandas.set_option("display.max_columns", None)
 pandas.set_option("display.expand_frame_repr", False)
-pandas.set_option("max_colwidth", -1)
+pandas.set_option("max_colwidth", None)
+pandas.options.mode.copy_on_write = True
 
 lock = threading.Lock()
-_rir_database: pandas.DataFrame = None
+_rir_database_v4: pandas.DataFrame = None
+_rir_database_v6: pandas.DataFrame = None
+_engine: Engine | None = None
 _countries: dict = dict()
 
 
-def convert_to_ip_object(
-    row: dict,
-) -> Union[Tuple[IPv4Address, IPv4Address], Tuple[IPv6Network, str], Tuple[str, str]]:
-    if row["Type"] == "ipv4":
-        start = IPv4Address(row["Start"])
-        return start, start + int(row["Value"])
-    elif row["Type"] == "ipv6":
-        return IPv6Network(row["Start"] + "/" + row["Value"]), ""
-    return row["Start"], ""
-
-
 def load_rir_databases() -> None:
     get_rir_database()
 
 
-def get_rir_database() -> pandas.DataFrame:
+def get_rir_database() -> Annotated[list[pandas.DataFrame], 3]:
     global lock
-    global _rir_database
+    global _rir_database_v4
+    global _rir_database_v6
     global _countries
-    if _rir_database is None:
+    if _rir_database_v4 is None:
         with lock:
-            if _rir_database is None:
+            if _rir_database_v4 is None:
                 logger.info("Loading RIR databases")
                 _rir_database = pandas.concat(read_rir_databases())
-                _rir_database = _rir_database[
-                    (
-                        (_rir_database["Type"] == "ipv4")
-                        | (_rir_database["Type"] == "ipv6")
-                    )
-                    & (_rir_database["Type"] != "*")
-                ]
-                _rir_database[["Start", "End"]] = _rir_database.apply(
-                    convert_to_ip_object, axis=1, result_type="expand"
+                _rir_database = _rir_database.drop(
+                    columns=["registry", "date", "extensions"]
+                )
+                _rir_database = _rir_database[_rir_database["type"] != "*"]
+                _rir_database_v4 = _rir_database[_rir_database["type"] == "ipv4"]
+                _rir_database_v4 = _rir_database_v4.drop(columns=["type"])
+                _rir_database_v6 = _rir_database[_rir_database["type"] == "ipv6"]
+                _rir_database_v6 = _rir_database_v6.drop(columns=["type"])
+                logger.info("extracted ipv4 or ipv6.")
+                _rir_database_v4["start"] = _rir_database_v4["start"].apply(
+                    lambda s: bytes([int(x) for x in s.split(".")]).hex()
+                )
+                _rir_database_v4["end"] = _rir_database_v4.apply(
+                    lambda row: (int(row["start"], 16) + int(row["value"]))
+                    .to_bytes(4, "big")
+                    .hex(),
+                    axis=1,
+                    result_type="expand",
                 )
+                _rir_database_v4 = _rir_database_v4.drop(columns=["value"])
+                logger.info("converted to objects(ipv4).")
+                _rir_database_v6["start"] = _rir_database_v6["start"].apply(
+                    lambda s: "".join(x.zfill(4) for x in s.split(":")).ljust(32, "0")
+                )
+                _rir_database_v6["end"] = _rir_database_v6.apply(
+                    lambda row: (int(row["start"], 16) + 2 ** (128 - int(row["value"])))
+                    .to_bytes(16, "big")
+                    .hex(),
+                    axis=1,
+                    result_type="expand",
+                )
+                _rir_database_v6 = _rir_database_v6.drop(columns=["value"])
+                logger.info("converted to objects(ipv6).")
+                logger.info("converted to objects(ip loaded).")
                 countries = pandas.read_csv(
                     os.path.join(
                         os.path.dirname(os.path.abspath(__file__)), "iso3166.csv"
                     ),
                     names=["country_code", "country_name"],
+                    keep_default_na=False,
+                    na_values=[""],
                 )
                 _countries = dict(
                     zip(
@@ -78,20 +99,81 @@ def get_rir_database() -> pandas.DataFrame:
                         countries["country_name"].values,
                     )
                 )
+                logger.info("country loaded.")
                 logger.info("RIR databases loaded")
-    return _rir_database
+    return [_rir_database_v4, _rir_database_v6, countries]
+
+
+class Base(DeclarativeBase):
+    pass
+
+
+class RirV4(Base):
+    __tablename__ = "rir_v4"
+    country_code: Mapped[Optional[str]] = mapped_column(String(2))
+    start: Mapped[str] = mapped_column(String(8), primary_key=True)
+    status: Mapped[str] = mapped_column(String(100))
+    end: Mapped[str] = mapped_column(String(8))
+
+    def __repr__(self) -> str:
+        return f"RirV4(country_code={self.country_code!r}, start={self.start!r}, status={self.status!r}, end={self.end!r})"
+
+
+class RirV6(Base):
+    __tablename__ = "rir_v6"
+    country_code: Mapped[Optional[str]] = mapped_column(String(2))
+    start: Mapped[str] = mapped_column(String(32), primary_key=True)
+    status: Mapped[str] = mapped_column(String(100))
+    end: Mapped[str] = mapped_column(String(32))
+
+    def __repr__(self) -> str:
+        return f"RirV6(country_code={self.country_code!r}, start={self.start!r}, status={self.status!r}, end={self.end!r})"
+
+
+class Country(Base):
+    __tablename__ = "country"
+    country_code: Mapped[str] = mapped_column(String(2), primary_key=True)
+    country_name: Mapped[str] = mapped_column(String(100))
+
+    def __repr__(self) -> str:
+        return f"Country(country_code={self.country_code!r}, country_name={self.country_name!r})"
+
+
+def to_database(
+    engine: Engine,
+    rir_v4: pandas.DataFrame,
+    rir_v6: pandas.DataFrame,
+    countries: pandas.DataFrame,
+) -> None:
+    logger.info("inserting from Dataframe into Database")
+    rir_v4.to_sql("rir_v4", engine, index=False, if_exists="append")
+    rir_v6.to_sql("rir_v6", engine, index=False, if_exists="append")
+    countries.to_sql("country", engine, index=False, if_exists="append")
+    logger.info("inserted from Dataframe into Database")
+
+
+def get_engine() -> Engine:
+    global _engine
+    if _engine is None:
+        _engine = create_engine("sqlite:///rir.db")  # , echo=True)
+        Base.metadata.create_all(_engine)
+        with Session(_engine) as session:
+            if session.scalar(select(func.count(RirV4.start))) == 0:
+                rir_v4, rir_v6, countries = get_rir_database()
+                to_database(_engine, rir_v4, rir_v6, countries)
+    return _engine
 
 
 def read_rir_databases():
     headers = [
-        "Registry",
-        "Country Code",
-        "Type",
-        "Start",
-        "Value",
-        "Date",
-        "Status",
-        "Extensions",
+        "registry",
+        "country_code",
+        "type",
+        "start",
+        "value",
+        "date",
+        "status",
+        "extensions",
     ]
     iptocc_dir = os.path.dirname(os.path.abspath(__file__))
     for rir_database in os.listdir(iptocc_dir):
@@ -111,47 +193,99 @@ def read_rir_databases():
             )[4:]
 
 
-@lru_cache(maxsize=100000)
-def ipv4_get_country_code(address: IPv4Address) -> str:
-    rir_database = get_rir_database()
-    ipv4_database = rir_database[rir_database["Type"] == "ipv4"]
-    result = ipv4_database[
-        (ipv4_database["Start"] <= address) & (ipv4_database["End"] > address)
-    ]
-    try:
-        return result["Country Code"].tolist()[0]
-    except IndexError:
-        raise CountryCodeNotFound
+def ipv4_get_country_code(address: str) -> str | None:
+    address = bytes([int(x) for x in address.split(".")]).hex()
+    engine = get_engine()
+    with Session(engine) as session:
+        statement = (
+            select(RirV4.country_code)
+            .where(
+                RirV4.start
+                == select(func.max(RirV4.start))
+                .where(RirV4.start <= address)
+                .scalar_subquery()
+            )
+            .where(RirV4.end > address)
+        )
+        return session.scalars(statement).first()
 
 
-@lru_cache(maxsize=100000)
-def ipv6_get_country_code(address: IPv6Address) -> str:
-    rir_database = get_rir_database()  # pandas.DataFrame
-    ipv6_database = rir_database[rir_database["Type"] == "ipv6"]
-    result = ipv6_database[
-        ipv6_database.apply(
-            lambda row: address in row["Start"], axis=1, result_type="expand"
+def ipv6_get_country_code(address: str) -> str | None:
+    address = "".join(x.zfill(4) for x in address.split(":")).ljust(32, "0")
+    engine = get_engine()
+    with Session(engine) as session:
+        statement = (
+            select(RirV6.country_code)
+            .where(
+                RirV6.start
+                == select(func.max(RirV6.start))
+                .where(RirV6.start <= address)
+                .scalar_subquery()
+            )
+            .where(RirV6.end > address)
         )
-    ]
-    try:
-        return result["Country Code"].tolist()[0]
-    except IndexError:
-        raise CountryCodeNotFound
+        return session.scalars(statement).first()
 
 
 def get_country_code(address: str) -> str:
-    address = ip_address(address)
-    if isinstance(address, IPv4Address):
-        logger.info("%s is IPv4", address)
-        return ipv4_get_country_code(address)
-    logger.info("%s is IPv6", address)
-    return ipv6_get_country_code(address)
+    ip = ip_address(address)
+    if isinstance(ip, IPv4Address):
+        logger.info("%s is IPv4", ip)
+        result = ipv4_get_country_code(address)
+    else:
+        logger.info("%s is IPv6", ip)
+        result = ipv6_get_country_code(address)
+    if result is None:
+        raise CountryCodeNotFound
+    return result
+
+
+def ipv4_get_country(address: str) -> str | None:
+    address = bytes([int(x) for x in address.split(".")]).hex()
+    engine = get_engine()
+    with Session(engine) as session:
+        statement = (
+            select(Country.country_name)
+            .select_from(RirV4)
+            .join(Country, RirV4.country_code == Country.country_code)
+            .where(
+                RirV4.start
+                == select(func.max(RirV4.start))
+                .where(RirV4.start <= address)
+                .scalar_subquery()
+            )
+            .where(RirV4.end > address)
+        )
+        return session.scalars(statement).first()
+
+
+def ipv6_get_country(address: str) -> str | None:
+    address = "".join(x.zfill(4) for x in address.split(":")).ljust(32, "0")
+    engine = get_engine()
+    with Session(engine) as session:
+        statement = (
+            select(Country.country_name)
+            .select_from(RirV6)
+            .join(Country, RirV6.country_code == Country.country_code)
+            .where(
+                RirV6.start
+                == select(func.max(RirV6.start))
+                .where(RirV6.start <= address)
+                .scalar_subquery()
+            )
+            .where(RirV6.end > address)
+        )
+        return session.scalars(statement).first()
 
 
 def get_country(address: str) -> str:
-    global _countries
-    try:
-        country_code = get_country_code(address)
-    except CountryCodeNotFound:
+    ip = ip_address(address)
+    if isinstance(ip, IPv4Address):
+        logger.info("%s is IPv4", ip)
+        result = ipv4_get_country(address)
+    else:
+        logger.info("%s is IPv6", ip)
+        result = ipv6_get_country(address)
+    if result is None:
         raise CountryNotFound
-    return _countries[country_code]
+    return result
diff --git a/pyproject.toml b/pyproject.toml
index effba83..dcdc059 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -33,17 +33,19 @@ classifiers = [
 update_rir = "updater:update_rir_databases"
 
 [tool.poetry.dependencies]
-python = ">=3.6.1,<4"
-pandas = "^1.0.1"
+python = ">=3.9,<4"
+pandas = "^2.2"
+sqlalchemy = "^2.0"
 
 [tool.poetry.dev-dependencies]
 codecov = "^2.0.16"
-pytest = "^5.4.1"
-pytest-cov = "^2.8.1"
+pytest = "^8"
+pytest-cov = "^5"
 flake8 = "^3.7.9"
-isort = "^4.3.21"
-safety = "^1.8.7"
+isort = "^5"
+safety = "^3.2"
 bandit = "^1.6.2"
+pipenv = ">=2024.0.1"
 
 [tool.isort]
 line_length = 99
diff --git a/tests/test_get_country.py b/tests/test_get_country.py
index b47093c..cad218a 100644
--- a/tests/test_get_country.py
+++ b/tests/test_get_country.py
@@ -12,14 +12,14 @@ PARAMS = [
     ("United States - IPv4", "5.35.192.0", "United States"),
     ("Sweden - IPv4", "5.35.184.0", "Sweden"),
     (
-        "United States - IPv6",
+        "United Kingdom - IPv6",
         "2a00:5440:0000:0000:0000:ff00:0042:8329",
-        "United States",
+        "United Kingdom",
     ),
     (
-        "United Kingdom - IPv6",
-        "2a00:95e0:0000:0000:0000:ff00:0042:8329",
-        "United Kingdom",
+        "United States - IPv6",
+        "2a00:95c0:0000:0000:0000:ff00:0042:8329",
+        "United States",
     ),
 ]
 
diff --git a/tests/test_get_country_code.py b/tests/test_get_country_code.py
index 4170a5b..b87668b 100644
--- a/tests/test_get_country_code.py
+++ b/tests/test_get_country_code.py
@@ -11,8 +11,16 @@ from iptocc import CountryCodeNotFound, get_country_code
 PARAMS = [
     ("United States - IPv4", "5.35.192.0", "US"),
     ("Sweden - IPv4", "5.35.184.0", "SE"),
-    ("United States - IPv6", "2a00:5440:0000:0000:0000:ff00:0042:8329", "US",),
-    ("United Kingdom - IPv6", "2a00:95e0:0000:0000:0000:ff00:0042:8329", "GB",),
+    (
+        "United Kingdom - IPv6",
+        "2a00:5440:0000:0000:0000:ff00:0042:8329",
+        "GB",
+    ),
+    (
+        "United States - IPv6",
+        "2a00:95c0:0000:0000:0000:ff00:0042:8329",
+        "US",
+    ),
 ]
 
 
```

## git cloneからの手順と使い方

### インストール手順

```console
$ git clone https://github.com/roniemartinez/IPToCC.git
...
$ python3 -m venv env
$ . env/bin/activate
(env) $ pip install -U pip setuptools
...
(env) $ cd IPToCC
(env) $ git apply <<EOF
(パッチをコピペ)
EOF
(env) $ rm poetry.lock
(env) $ make install
...
(env) $ rm iptocc/delegated-*
(env) $ python updater.py
...
(env) $ 
```

### 使い方

```console
(env) $ python
...
>>> import iptocc
>>> iptocc.get_country('51.222.253.5')
'Canada'
>>> 
```

初回はデータベースの構築をするので20秒くらい？かかります。2回目の実行では作成したデータベースを参照するだけなので、すぐ結果が返ります。

### RIRデータベースの更新

以下の手順が必要です。

```console
(env) $ rm iptocc/delegated-*
(env) $ python updater.py
...
(env) $ rm rir.db
```

あとは初回実行をすればデータベースが作成されます。

### SQLを知りたい場合

```python:iptocc/__init__.py
...
        _engine = create_engine("sqlite:///rir.db")  # , echo=True)
...
```

ここを

```python:iptocc/__init__.py
...
        _engine = create_engine("sqlite:///rir.db", echo=True)
...
```

こう変えます。この状態で実行すると、SQL Alchemyが生成するSQLを含めていろいろエコーされます。

上の例だとこんなSQLを発行しています。

```sql
SELECT country.country_name 
FROM rir_v4 JOIN country ON rir_v4.country_code = country.country_code 
WHERE rir_v4.start = (SELECT max(rir_v4.start) AS max_1 
FROM rir_v4 
WHERE rir_v4.start <= '33defd05') AND rir_v4."end" > '33defd05';
```

この結果がCanadaなだけです。なので上記のようなSQLが発行できれば、検索だけならpythonに拘る必要はありません。

## SQLite3でないデータベースを使いたい場合

create_engineの引数文字列を変えれば簡単に別のデータベースにも変えられると思います(ドライバは入れる必要があります)。

### PostgreSQLの例

```yaml:docker-compose.yml
services:
  db:
    image: postgres
    restart: always
    volumes:
      - ./data:/var/lib/postgresql/data
    ports: 
      - "5432:5432"
    environment:
      POSTGRES_PASSWORD: example
```

上記を用意して、docker compose up -dしてpostgresを起動します。

次にpostgres用のpythonドライバをインストールします。

```console
(env) $ poetry add psycopg2-binary
...
(env) $ 
```

あとはengineの接続文字列を変えるだけです。

```python:iptocc/__init__.py
...
        _engine = create_engine("postgresql+psycopg2://postgres:example@localhost/postgres", echo=True)
...
```

echo=Trueにしているので、初回たくさんSQLなどが発行されてるのが見えると思います。postgresqlはdocker compose downで停止します。

## 今回の修正の簡単な説明

- IPアドレスをオブジェクトから16進数文字列に変更し、一般的なRDBMSへ格納しやすい形にした
- pandasのカラム名がデータベースで扱いにくい形だったので、小文字化と空白をアンダースコアにした
- 不要なカラムを積極的に削除した
- startカラムを主キーとしてSQL AlchemyのORMを使ってSQLite3に保存した

## 追記その2のまとめ

- SQL Alchemyを使ってSQLite3に格納した

実用上はRIRデータベースの更新を反映するためにデータベースを作り直して20秒も止めるのは論外なので、一時テーブル上に構築し、差分検出とその一括反映など、何らかの措置が必要だが、運用にもよるので本稿では扱わない。

